<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Duelingbook - Replay</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=1024">
<meta name="title" content="Duelingbook" />
<meta name="description" content="Duelingbook is a Yu-Gi-Oh! Trading Card Game simulator that works right in your browser." />
<meta name="keywords" content="yugioh" />
<meta property="og:title" content="Replay" />
<meta property="og:type" content="website" />
<meta property="og:description" content="Duelingbook is a Yu-Gi-Oh! Trading Card Game simulator that works right in your browser." />
<meta property="og:image" content="https://www.duelingbook.com//site_image.jpg" />
<meta property="og:url" content="https://www.duelingbook.com" />
<meta property="og:site_name" content="Duelingbook" />
<link rel="stylesheet" type="text/css" href="static/main.css?v=799">

<link rel="stylesheet" type="text/css" href="static/overlayscrollbars.min.css?v=2">
<script src="static/jquery.min.js"></script>
<script src="static/jquery-ui.min.js"></script>
<script src="static/jquery.ui.touch-punch.min.js"></script>

<script src="static/overlayscrollbars.browser.es5.min.js" defer></script>
<script src="static/snap.svg-min.js"></script>
<script src="static/SnapSVGAnimator.min.js"></script>
<script src="static/TweenMax.min.js"></script>
<script src="static/watch.min.js"></script>
<script src="static/detect-zoom.js?v=2"></script>
<script src="https://www.google.com/recaptcha/api.js?render=6LcjdkEgAAAAAKoEsPnPbSdjLkf4bLx68445txKj" data-cfasync="false"></script>
<script src="https://hb.vntsm.com/ab/live/hera/ad-manager.min.js" type="text/javascript" data-site-id="61559d8972dc634ba6c642fe" data-mode="scan" async></script>
<style>
			.like_btn {
				left: 8px;
				top: 615px;
				display: none;
			}
		</style>
</head>
<body>
<div id="black" style="background-color: black; width: 100%; height: 100%; z-index: 99;"></div>
<div id="content" class="unselectable" style="display: none;">
<img id="circuit_board" src="images/circuit_board_small.jpg" width="1024" height="724" alt="Background" />
<div id="circuit_cover"></div>
<div id="greenlines">
<div id="greenlines1">
<img src="images/svg/greenlines.svg" alt="Green Lines" />
</div>
<div id="greenlines2">
<img src="images/svg/greenlines.svg" alt="Green Lines" />
</div>
</div>
<div id="dark"></div>
<div id="frames">
<div id="start"></div>
<div id="duel">
<img id="field_spell_pic" src="images/blank.png" alt="Field Spell" />
<div id="rps_start" class="duel_frame"></div>
<div id="tp_start" class="duel_frame">
<img id="field_decks" class="field_decks" src="images/svg/field_decks.svg" alt="Decks" />
</div>
<div id="tp_start2" class="duel_frame">
<img id="field_decks2" class="field_decks" src="images/svg/field_decks2.svg" alt="Decks" />
</div>
<div id="duel_start" class="duel_frame">
<img id="field_zones" class="field_zones" src="images/svg/field_zones.svg" alt="Field" />
</div>
<div id="duel_start1" class="duel_frame">
<img id="field_zones" class="field_zones" src="images/svg/field_zones1.svg" alt="Field" />
</div>
<div id="duel_start2" class="duel_frame">
<img id="field_zones2" class="field_zones" src="images/svg/field_zones2.svg" alt="Field" />
</div>
<div id="duel_start3" class="duel_frame">
<img id="field_zones3" class="field_zones" src="images/svg/field_zones3.svg" alt="Field" />
</div>
<div id="duel_start4" class="duel_frame">
<img id="field_zones4" class="field_zones" src="images/svg/field_zones4.svg" alt="Field" />
</div>
<div id="ss_spiral">
<img src="images/ss_spiral_small.png" alt="Spiral" />
</div>
<div id="ss_glow">
<img src="images/ss_glow_small.png" alt="Glow" />
</div>
<div id="field"></div>
<div class="preview"></div>
<div id="preview_txt" class="textarea" tabindex="0"></div>
<div id="duel_content" class="duel_frame">
<div id="field_content">
<div id="turn">
<img class="background" src="images/svg/turn_background.svg" alt="Turn Background" />
<img class="blue" src="images/svg/turn_blue.svg" alt="Turn Blue" />
<img class="red" src="images/svg/turn_red.svg" alt="Turn Red" />
<span class="arial_rounded20">TURN</span>
</div>
</div>
<div id="field_stats">
<span id="hm1_txt" class="field_stats"></span>
<span id="hm2_txt" class="field_stats"></span>
<span id="hm3_txt" class="field_stats"></span>
<span id="hm4_txt" class="field_stats"></span>
<span id="hm5_txt" class="field_stats"></span>
<span id="om1_txt" class="field_stats"></span>
<span id="om2_txt" class="field_stats"></span>
<span id="om3_txt" class="field_stats"></span>
<span id="om4_txt" class="field_stats"></span>
<span id="om5_txt" class="field_stats"></span>
<span id="hl_txt" class="field_stats"></span>
<span id="ol_txt" class="field_stats"></span>
</div>
<div id="counters"></div>
<div id="hidden_spots">
<span id="deck_hidden"></span>
<span id="grave_hidden"></span>
<span id="banished_hidden"></span>
<span id="extra_hidden"></span>
<span id="opp_deck_hidden"></span>
<span id="opp_grave_hidden"></span>
<span id="opp_banished_hidden"></span>
<span id="opp_extra_hidden"></span>
</div>
<div id="numbers">
<span id="cid1_txt">0</span>
<span id="cig1_txt">0</span>
<span id="cib1_txt">0</span>
<span id="cie1_txt">0</span>
<span id="cid2_txt">0</span>
<span id="cig2_txt">0</span>
<span id="cib2_txt">0</span>
<span id="cie2_txt">0</span>
</div>
<div class="cards"></div>
<div id="spark"></div>
<div id="red_stream"></div>
<div id="blue_stream"></div>
<div class="red_target target">
<img src="images/svg/red_target.svg" alt="Target" />
</div>
<div class="blue_target target">
<img src="images/svg/blue_target.svg" alt="Target" />
</div>
<div class="green_target target">
<img src="images/svg/green_target.svg" alt="Target" />
</div>
<div id="sword">
<img src="images/svg/sword.svg" alt="Sword" />
</div>
<div id="coin">
<img class="tails" src="images/coin_tails.png" alt="Tails" />
<img class="heads" src="images/coin_heads.png" alt="Heads" />
</div>
<div id="die" class="reset">
<div id="side1" class="face">
<div class="shader"></div>
</div>
<div id="side2" class="face">
<div class="shader"></div>
</div>
<div id="side3" class="face">
<div class="shader"></div>
</div>
<div id="side4" class="face">
<div class="shader"></div>
</div>
<div id="side5" class="face">
<div class="shader"></div>
</div>
<div id="side6" class="face">
<div class="shader"></div>
</div>
</div>
<div id="shine"></div>
<div id="view">
<img class="background" src="images/svg/view.svg" alt="View Cards" />
<span class="title_txt arial_rounded20">Viewing Graveyard</span>
<div class="exit_btn">
<img src="images/svg/exit_btn_up.svg" alt="Exit" />
</div>
<div class="content"></div>
</div>
</div>
<div id="siding" class="duel_frame">
<img class="deck_constructor" src="images/svg/deck_constructor.svg" alt="Deck" />
<span id="siding_in_progress">Siding in progress! Please wait...</span>
</div>
<div id="viewing"></div>
<div id="watchers_btn">
<img src="images/watchers_btn_up.png" width="34" height="34" alt="Watchers" />
</div>
<div id="log_btn">
<img src="images/log_btn_up.png" width="41" height="37" alt="Duel Log" />
</div>
<input id="show_rb" type="radio" name="show" />
<span id="show_lbl">Hide Hands</span>
<input id="play_btn" type="submit" value="Play" />
<input id="show1_rb" type="radio" name="show" checked="checked" />
<span id="show1_lbl">Show Hand</span>
<input id="pause_replay_btn" type="submit" value="Pause" />
<input id="show2_rb" type="radio" name="show" />
<span id="show2_lbl">Show Both</span>
<div class="like_btn">
<img src="images/svg/like_btn_up.svg" alt="Like" />
</div>
<input id="next_btn" type="submit" value="Next Play" />

<input id="fast_btn" type="submit" value="Fast Forward" />
<div id="watchers">
<span class="watchers_txt">Watchers: 0</span>
<div class="users list"></div>
</div>
<div id="lifepoints2" class="lifepoints">
<div class="life_bar">
<div class="black_bar"></div>
</div>
<div class="life_border"></div>
<span class="life_txt">8000</span>
</div>
<span id="done_siding2">Done siding!</span>
<div id="avatar2" class="duel_avatar">
<img class="image" src="images/loading.gif" alt="Loading" />
<div class="nsfw"></div>
<img class="think" src="images/think.png" alt="Thinking" />
<div class="all_good">
<img src="images/svg/like_btn_up.svg" alt="All Good" />
<span class="keep_going">Keep<br>Going!</span>
</div>
<div id="bubbles2" class="bubbles"></div>
<div class="rating">
<span class="rating_txt">rating/rep</span>
</div>
<input class="nsfw_btn" type="submit" value="Show Image" />
<span class="username_txt selectable">Username</span>
</div>
<div id="avatar4" class="duel_avatar">
<img class="image" src="images/loading.gif" alt="Loading" />
<div class="nsfw"></div>
<img class="think" src="images/think.png" alt="Thinking" />
<div class="all_good">
<img src="images/svg/like_btn_up.svg" alt="All Good" />
<span class="keep_going">Keep<br>Going!</span>
</div>
<div id="bubbles4" class="bubbles"></div>
<div class="rating">
<span class="rating_txt">rating/rep</span>
</div>
<input class="nsfw_btn" type="submit" value="Show Image" />
<span class="username_txt selectable">Username</span>
</div>
<div id="status2" class="duel_status">
<span class="status_txt arial_rounded25">Viewing<br>XXXXX<br>XXXXX</span>
</div>
<div id="gone2" class="gone"></div>
<div id="countdown2">300</div>
<div class="cout_txt textarea" tabindex="0"></div>
<div id="avatar1" class="duel_avatar">
<img class="image" src="images/loading.gif" alt="Loading" />
<div class="nsfw"></div>
<img class="think" src="images/think.png" alt="Thinking" />
<div id="bubbles1" class="bubbles"></div>
<div class="rating">
<span class="rating_txt">rating/rep</span>
</div>
<input class="nsfw_btn" type="submit" value="Show Image" />
<div class="all_good">
<img src="images/svg/like_btn_up.svg" alt="All Good" />
<span class="keep_going">Keep<br>Going!</span>
</div>
<span class="username_txt selectable">Username</span>
</div>
<div id="avatar3" class="duel_avatar">
<img class="image" src="images/loading.gif" alt="Loading" />
<div class="nsfw"></div>
<img class="think" src="images/think.png" alt="Thinking" />
<div class="all_good">
<img src="images/svg/like_btn_up.svg" alt="All Good" />
<span class="keep_going">Keep<br>Going!</span>
</div>
<div id="bubbles3" class="bubbles"></div>
<div class="rating">
<span class="rating_txt">rating/rep</span>
</div>
<input class="nsfw_btn" type="submit" value="Show Image" />
<span class="username_txt selectable">Username</span>
</div>
<div id="status1" class="duel_status">
<span class="status_txt arial_rounded25">Viewing<br>XXXXX<br>XXXXX</span>
</div>
<input id="next_game_btn" type="submit" value="Next Game" />
<div id="gone1" class="gone"></div>
<div id="countdown1">300</div>
<div id="over">
<img src="images/svg/over.svg" alt="Over" />
<span class="title_txt">Duel Over</span>
<span class="body_txt">Sample message<br>Sample message<br>Sample message</span>
<div class="ok_btn">
<img src="images/svg/ok_btn_up.svg" alt="OK" />
</div>
</div>
<div id="lifepoints1" class="lifepoints">
<div class="life_bar">
<div class="black_bar"></div>
</div>
<div class="life_border"></div>
<span class="life_txt">8000</span>
</div>
<span id="done_siding1">Done siding!</span>
</div>
</div>
<div id="chats">
<div id="watch_chat" class="chat">
<div class="chat_top">
<div class="chat_top_bg">
<span>Watcher's Chat</span>
</div>
<div class="minimize_btn">
<img src="images/svg/minimize_btn_up.svg" alt="Minimize" />
</div>
</div>
<div class="chat_background">
<div class="cout_txt textarea" tabindex="0"></div>
<input class="cin_txt" type="text" />
</div>
</div>
<div id="duel_log" class="chat">
<div class="chat_top">
<div class="chat_top_bg">
<span>Duel Log</span>
</div>
<div class="minimize_btn">
<img src="images/svg/minimize_btn_up.svg" alt="Minimize" />
</div>
</div>
<div class="chat_background">
<div class="log">
<div class="log_txt textarea" tabindex="0"></div>
<div class="log_tools">
<input class="chat_cb" type="checkbox" checked="checked" autocomplete="off" />
<span class="chat_lbl">Chat</span>
<input class="duel_cb" type="checkbox" checked="checked" autocomplete="off" />
<span class="duel_lbl">Duel</span>
<input class="game_cb" type="checkbox" checked="checked" autocomplete="off" />
<span class="game_lbl">Game</span>
<input class="private_cb" type="checkbox" checked="checked" autocomplete="off" />
<span class="private_lbl">Private Info</span>
<input class="usernames_cb" type="checkbox" autocomplete="off">
<span class="usernames_lbl">Usernames</span>
<div class="black_line"></div>
<input class="search_txt" type="text" />
<img class="lookup" src="images/svg/lookup.svg" alt="Search" />
</div>
</div>
</div>
</div>
</div>
<div id="screenshot_btn">
<div class="hidden"></div>
<img src="images/svg/screenshot_btn_up.svg" alt="Screenshot" />
</div>
<div id="mute_btn">
<img src="images/svg/mute_btn_up.svg" alt="Sound" />
</div>
<div id="cross">
<img src="images/svg/cross.svg" alt="Sound Off" />
</div>
<div id="tooltips" class="aliased">
<div id="watch_chat_tooltip">Watchers</div>
<div id="log_tooltip">Log</div>
</div>
<div id="dim">
<div class="background"></div>
</div>
<div id="msg">
<span class="title_txt">Message</span>
<div class="body_txt selectable">Sample message<br>Sample message<br>Sample message</div>
<div class="ok_btn">
<img src="images/svg/ok_btn_up.svg" alt="OK" />
</div>
</div>
<div id="recaptcha_bg">
<div class="recaptcha"></div>
</div>
<div id="recaptcha_bg2">
<div class="recaptcha"></div>
</div>
</div>
<div id="mes1">
<div class="vm-placement vm-banner-ad" data-id="61572783ec3b93764e77eec0"></div>
</div>
<div id="mes2">
<div class="vm-placement" data-id="62de362b8922672aafb908d6"></div>
</div>
<div id="mes3">
<div class="vm-placement vm-banner-ad" data-id="61572783ec3b93764e77eec0"></div>
</div>
<div id="mes4"></div>
<script src="static/utils.js?v=799"></script>
<script src="static/duel.js?v=799"></script>
<script>
		    var __GAMESTATE
			var status = "";
			var master = 2;
			var key;
			show_cards = localStorage.getItem("show_cards") == "true";
			var gotoSeconds = 0;
			var game_number = GET('game');
			var match_number = GET('match');
			
			var username;
			//var version = 0;
			var stopped = false;
			stopQueue = false;
			var skipping = false;
			var replay_arr = [];
			var seconds = 0;
			var fast_forwarding = false;
			var ready = false;
			var resume_play = false;
			var show_cards = 0;
			//var content = "";
			var easeSeconds3 = 0.2; // RPS
			var easeSeconds4 = 0.75; // TS, field_decks_mc
			var easeSeconds5 = 0.75; // field_content
			var unknown_main_total = 0;
			var unknown_extra_total = 0;
			var startingHandSize = 5;
			var FAST_PLAYS = ["Add watcher", "Remove watcher", "Duel message", "Watcher message", "Shuffle deck"];
			var GENERAL_PLAYS = ["Call admin", "Cancel call", "Admit defeat", "Quit duel", "Offer draw", "Revoke draw", "Accept draw", "Offer rematch", "Revoke rematch", "Game loss", "Match loss", "Loss", "Cancel game", "Accept rematch", "Siding", "Begin next duel", "Back to RPS", "Add watcher", "Remove watcher", "Duel message", "Watcher message", "Show deck", "Left duel", "Rejoin duel", "Resume game", "Message", "Thinking", 	"Permission event"];
			var IGNORED_PLAYS = ["Swap cards", "Countdown"];
			var RPS_PLAYS = ["RPS"];
			var SIDING_PLAYS = ["Done siding"];
			var TP_PLAYS = ["Pick first", "Preview Skillback"];
			var showMes = 0;
			var timer = new Timer(500);
			timer.callback = timerE;
			replay = true;
			var conceal = GET('conceal') == 'true';
			var recaptcha_version = 3;
			var previous_plays = [];
			
			addButton($('.like_btn'), likeReplay);
			$('#play_btn').click(playE);
			$('#pause_replay_btn').click(pauseE);
			$('#next_btn').click(nextE);
			$('#backward_btn').click(stepBackwardE);
			$('#fast_btn').click(fastE);
			$('#show_rb').change(showNone);
			$('#show1_rb').change(showOne);
			$('#show2_rb').change(showBoth);
			$('#next_game_btn').mouseenter(showRating);
			$('#next_game_btn').mouseout(showRating);
			$('#next_game_btn').click(nextGameE);
			if (master < 2) {
				$('#show2_rb').hide();
			}
			if (master < 1) {
				$('#show_rb').hide();
				$('#show1_rb').hide();
			}
			preview_txt.mouseleave(function(){
				$('#log_btn').show();
			});
			TweenMax.ticker.useRAF(false);
			TweenMax.lagSmoothing(0);
			window.onload = loadedE;
						
			function loadedE() {
				$('.grecaptcha-badge').css("visibility", "hidden");
				initDB();
				//$('#next_game_btn').data("proxy").hide();
				$('#next_game_btn').data("proxy").css("opacity", 0);
				goto("start");
				image_url = 'https://www.duelingbook.com/replay?id=' + duelId;
				if (status.indexOf('Duel is still in progress') == 0) {
					errorE(status);
					return;
				}
				if (status.indexOf('Invalid link') == 0) {
					errorE(status);
					return;
				}
				
				//duelId = 12753182;
				//duelId = 12889341;
				//duelId = 14603778;
				
				
				//duelId = 17309916;
				//duelId = 19185218;
				
				//duelId = 23588751;
				//duelId = 13207124;
				//userId = 424005;
				
				//duelId = 34885188;
				//duelId = 39936975;
				//duelId = 44103054;
				//duelId = 50807989;
				
				//loadReplay(duelId);				
				
				
				loadRecaptchaV3();
			}
			
			// v2
			function loadRecaptchaV2() {
			    //recaptcha_version = 2;
			    recaptcha_version = 1;
				$('#recaptcha_bg2').show();
				$('.grecaptcha-badge:last').css("visibility", "hidden");
				//grecaptcha.render($('#recaptcha_bg2 .recaptcha')[0], {"sitekey":"6LdgBP8fAAAAAE7oh2Qc-MqjzJhS0qUwBSE0o8NJ", "callback":"recaptchaCallback"}); // medium
				//grecaptcha.render($('#recaptcha_bg2 .recaptcha')[0], {"sitekey":"6LcwzlIlAAAAAHlxDi-6x9fzGhyfUXnAaYOyW0KD", "callback":"recaptchaCallback"}); // hard
				grecaptcha.render($('#recaptcha_bg2 .recaptcha')[0], {"sitekey":"6Lfxs4UpAAAAACPI4AMlz93641xvw9JI2s9fCKYN", "callback":"recaptchaCallback"}); // easy
			}
			
            function recaptchaCallback(token) {
                loadReplay(token);
            }
            
			// v3
			function loadRecaptchaV3() {
				console.log('loadRecaptcha');
				recaptcha_version = 3;
				$('#recaptcha_bg').show();
				$('.grecaptcha-badge').css("visibility", "visible");
				$('.grecaptcha-badge:last').css("visibility", "hidden");
				var clientId = grecaptcha.render($('#recaptcha_bg .recaptcha')[0], {
					'sitekey': '6LcjdkEgAAAAAKoEsPnPbSdjLkf4bLx68445txKj',
					'badge': 'inline',
					'size': 'invisible'
				});
				$('.grecaptcha-badge:first').css("visibility", "visible");
				grecaptcha.ready(function() {
					grecaptcha.execute(clientId, {
						action: 'submit'
					})
					.then(function(token) {
						loadReplay(token);
					});
				});
			}
			
			function hideRecaptcha() {
				$('#recaptcha_bg, #recaptcha_bg2').hide();
			}
			
			function loadReplay(token) {
			    //console.log('token = ' + token);
			
				var fd = new FormData();
				fd.append("token", token);
				fd.append("recaptcha_version", recaptcha_version);
				fd.append("master", GET('master'));
				
				//duelId = GET('id') ? ~~GET('id') : duelId;
				duelId = GET('id');
				//duelId = duelId.indexOf("-") >= 0 ? ~~duelId.substring(duelId.indexOf("-") + 1) : ~~duelId;
				if (duelId.indexOf("-") >= 0) {
				    userId = ~~duelId.substring(0, duelId.indexOf("-"));
				    duelId = ~~duelId.substring(duelId.indexOf("-") + 1);
				}
				else {
				    duelId = ~~duelId;
				}
				
				
				
				var url = URL_START + "view-replay?id=" + (userId ? userId + '-' + duelId : duelId);
				if (!duelId) {
					url = "sample.txt";
				}
				
				console.log(url);
				
				var xhr = new XMLHttpRequest();
				xhr.open("POST", url, true);
				xhr.onreadystatechange = function() {
					if (xhr.readyState == 4 && xhr.status == 200) {
						loadReplayComplete(xhr.responseText);
					}
				};
				xhr.onerror = ioError;
				xhr.send(fd);
				dim.playing = true;
				showDim();
			}
			
			function ioError() {
				errorE("Replay does not exist");
			}

			function loadReplayComplete(str) {
				hideRecaptcha();
				console.log(str);
				var data;
				try {
					data = JSON.parse(str);
				}
				catch(err) {
					errorE("Failed to read replay data");
					return;
				}
				hideDim();
				if (data.action == "Error") {
				    if (data.message == "Invalid Token") {
				        loadRecaptchaV2();
				        return;
				    }
					errorE(data.message);
					return;
				}
				version = ~~data.version;
				if (data.unknown_totals) {
					unknown_totals = true;
					unknown_main_total = data.player1.main_total;
					unknown_extra_total = data.player1.extra_total;
				}
				if (data.player1.user_id == userId) {
					username = data.player1.username; // why is username needed? it's making me have to add && duelist to everything // because it's baked into a lot of other code already
				}
				//else if (data.player2.user_id == userId && userId != 0) {
				else if (data.player2.user_id == userId && userId != 0 || GET('player') == 2) {
					console.log("You are " + data.player2.username);
					username = data.player2.username;
					switched = true;
					switchDuelists(data, "player1", "player2");
				}
				if (userId != 0 && master < 2) {
					if (userId != data.player1.user_id && userId != data.player2.user_id) {
						master = 0;
						show_cards = 0;
					}
				}
				if (data.version < 2 && show_cards == 2) {
					show_cards = 0;
				}
				
				
				if (game_number) {
					var games_found = 1;
					for (var i = 0; i < data.plays.length; i++) {
						if (data.plays[i].play == "Begin next duel" || data.plays[i].play == "Back to RPS") {
							data.plays.splice(0, i);
							i = 0;
							games_found++;
							if (games_found == game_number) {
								break;
							}
						}
					}
				}
				if (conceal) {
					data.player1.pic = "1001.jpg";
					data.player2.pic = "513.jpg";
					if (data.player3 && parseInt(data.player3.pic) > 20000) {
						data.player3.pic = "1613.jpg";
					}
					if (data.player4 && parseInt(data.player4.pic) > 20000) {
						data.player4.pic = "3540.jpg";
					}
				}
				startDuel(data);
				replay_arr = data.plays;
				initRPSStart();
				getShowCards();
				initWatcher();
				initPlayers(data);
				if (data.logs) {
					console.log("JSON.stringify(data.logs[0]) = " + JSON.stringify(data.logs[0]));
					duelLogPrint(data.logs[0]);
					duelLogPrint(data.logs[1]);
				}
				seconds = replay_arr[0].seconds - 1;
				showNextGame();
				if (gotoSeconds > 0) {
					skipping = true;
					gotoPlay();
				}
				else {
					playE();
				}
				if (!show_cards) {
					$('#duel_log .private_cb').checked(false);
					$('#duel_log .private_cb').disable(true);
				}
				$('#log_btn').show();
				
				if (data.conceal) {
					$('#show_rb').hide();
					$('#show_lbl').hide();
					$('#show1_rb').hide();
					$('#show1_lbl').hide();
					$('#show2_rb').hide();
					$('#show2_lbl').hide();
					showNone();
				}
				if (conceal) {
					if (tag_duel) {
						expandAvatar($('#avatar1 .username_txt'), "Red", "Partner");
						expandAvatar($('#avatar2 .username_txt'), "Blue", "Partner");
						expandAvatar($('#avatar3 .username_txt'), "Partner", "Red");
						expandAvatar($('#avatar4 .username_txt'), "Partner", "Blue");
					}
					else {
						$('#avatar1 .username_txt').text("Red");
						$('#avatar2 .username_txt').text("Blue");
					}
					$('#over').detach();
				}
				loadCards(cards_fingerprint);
			}
			
			/*function showNextGame() {
				$('#next_game_btn').hide();
				for (var i = 0; i < replay_arr.length; i++) {
					if (replay_arr[i].play == "Begin next duel" || replay_arr[i].play == "Back to RPS") {
						$('#next_game_btn').show();
						return;
					}
				}
			}*/
			
			function showNextGame() {
				for (var i = 3; i < replay_arr.length; i++) {
					if (replay_arr[i].play == "Begin next duel" || replay_arr[i].play == "Back to RPS") {
						return;
					}
				}
				if ($('#next_game_btn').length > 0) {
					$('#next_game_btn').data("proxy").detach();
					$('#next_game_btn').detach();
				}
			}
			
			function nextGameE() {
				outerloop:
				for (var i = 0; i < replay_arr.length; i++) {
					switch(replay_arr[i].play) {
						case "Siding":
						case "Begin next duel":
						case "Back to RPS":
							replay_arr.splice(0, i);
							seconds = replay_arr[0].seconds;
							timerE();
							break outerloop;
					}
				}
				showNextGame();
			}
			
			function timerE() {
			    //console.log('timerE');
			    //console.log(JSON.stringify(replay_arr[0]));
			    if (actionsQueue.length > 1) { // 1 is perfect, 0 would make some plays not instant
			        return; // added 7-13-23 love this return, makes pause button stop the game instantly
			    }
			
				seconds += 0.5;
				//console.log("seconds = " + seconds);
				if (seconds >= gotoSeconds) {
					skipping = false;
				}
				if (replay_arr.length == 0) {
					timer.stop();
					timer.reset();
					$('#play_btn').disable(true);
					$('#pause_replay_btn').disable(true);
					$('#next_btn').disable(true);
					$('#fast_btn').disable(true);
					return;
				}
				for (var i = 0; i < replay_arr.length; i++) {
					if (replay_arr[0].play == "Countdown") {
						console.log('doing');
						replay_arr[0].seconds = seconds;
					}
					if (replay_arr[0].seconds <= seconds) {
						if (replay_arr[0].play) {
							if (IGNORED_PLAYS.indexOf(replay_arr[0].play) >= 0) {
								replay_arr.splice(0, 1);
								i--;
								continue;
							}
							if (currentLabel.indexOf("rps_start") >= 0) {
								if (RPS_PLAYS.indexOf(replay_arr[0].play) < 0 && GENERAL_PLAYS.indexOf(replay_arr[0].play) < 0) {
									if (TP_PLAYS.indexOf(replay_arr[0].play) >= 0) {
										rpsNext();
									}
									else {
										console.log("RETURNING ON LINE A");
										return;
									}
								}
							}
							else if (currentLabel.indexOf("tp_start") >= 0) {
								console.log("THE LABEL IS " + currentLabel);
								if (TP_PLAYS.indexOf(replay_arr[0].play) < 0 && GENERAL_PLAYS.indexOf(replay_arr[0].play) < 0 && SIDING_PLAYS.indexOf(replay_arr[0].play) < 0 ) {
									// some games have "Done Siding" 3 times for some reason, so adding SIDING_PLAYS here will help with that
									console.log("RETURNING ON LINE B. SIDING_PLAYS[0] = "+ TP_PLAYS[0] + ", replay_arr[0].play = " + replay_arr[0].play);
									return;
								}
							}
							else if (currentLabel.indexOf("siding") >= 0) {
								if (SIDING_PLAYS.indexOf(replay_arr[0].play) < 0 && GENERAL_PLAYS.indexOf(replay_arr[0].play) < 0) {
									replay_arr.splice(0, 1);
									i--;
									return;
									/*if (replay_arr[0].play.indexOf("View") != 0 && replay_arr[0].play != "Stop viewing" && replay_arr[0].play != "Draw card" && replay_arr[0].play.indexOf("Enter") != 0 && replay_arr[0].play != "Summon Token" && replay_arr[0].play != "Add counter" && replay_arr[0].play != "To GY") {
										console.log("RETURNING ON LINE C. SIDING_PLAYS[0] = "+ SIDING_PLAYS[0] + ", replay_arr[0].play = " + replay_arr[0].play);
										return;
									}*/
								}
							}
							else if (currentLabel.indexOf("duel_start") >= 0) {
								if (RPS_PLAYS.indexOf(replay_arr[0].play) >= 0 || TP_PLAYS.indexOf(replay_arr[0].play) >= 0 || SIDING_PLAYS.indexOf(replay_arr[0].play) >= 0 || !ready) {
									console.log("RETURNING ON LINE D. replay_arr[0].play = " + replay_arr[0].play);
									return;
								}
							}
							// Sometimes there are two instances of the exact same play in a row as the result of a glitch, and this will help prevent that problem
							//if (JSON.stringify(lastAction) == JSON.stringify(replay_arr[0]) && GENERAL_PLAYS.indexOf(replay_arr[0].play) < 0) {
							if (VERSION < 725 && JSON.stringify(lastAction) == JSON.stringify(replay_arr[0]) && GENERAL_PLAYS.indexOf(replay_arr[0].play) < 0) { // modified to accomodate for stepBackward
								replay_arr.splice(0, 1);
								i--;
								continue;
							}
							lastAction = replay_arr[0];
							previous_plays.push(replay_arr[0]);
							console.log('adding ' + replay_arr[0].play + ' to previous_plays');
						}
						if (duelResponse0(replay_arr[0])) {
						    
						}
						//console.log('removing ' + replay_arr[0].play + ' from replay_arr');
						replay_arr.splice(0, 1);
						i--;
						printQueue(lastAction.play); // lastAction might not be correct
						break; // added 1/22/18 (so cards like pot of desires don't do 10 actions at once)
						//return;
					}
					else {
						if (IGNORED_PLAYS.indexOf(replay_arr[0].play) >= 0) {
							replay_arr.splice(0, 1);
							i--;
							continue;
						}
						//console.log("replay_arr[0].seconds = " + replay_arr[0].seconds);
						if (replay_arr[0].seconds == undefined) {
							//console.log("replay_arr[0] = " + JSON.stringify(replay_arr[0])); // enabling causes errors
						}
						//console.log("seconds = " + seconds);
						break;
					}
				}
				if (fast_forwarding) {
					//if (!stopQueue) {
					if (!stopQueue || skipping) {
						var num_fast_plays = 0;
						while (true) {
							if (replay_arr.length > 0) {
								seconds = replay_arr[0].seconds - 0.5;
								if (replay_arr[0].play) {
									if (FAST_PLAYS.indexOf(replay_arr[0].play) >= 0 && num_fast_plays <= 0) {
										duelResponse0(replay_arr[0]);
										replay_arr.splice(0, 1);
										num_fast_plays++;
									}
									else if (GENERAL_PLAYS.indexOf(replay_arr[0].play) < 0 && RPS_PLAYS.indexOf(replay_arr[0].play) < 0 && TP_PLAYS.indexOf(replay_arr[0].play) < 0 && SIDING_PLAYS.indexOf(replay_arr[0].play) < 0) {
										timerE();
										break;
									}
									else {
										console.log("replay_arr[0].play = " + replay_arr[0].play);
										break;
									}
								}
								else {
									console.log("replay_arr[0] = " + replay_arr[0]);
									break;
								}
							}
							else {
								console.log("replay_arr.length = " + replay_arr.length);
								break;
							}
						}
					}
					else {
						console.log("stopQueue = " + stopQueue);
						//console.log("timer.delay = " + timer.delay);
					}
				}
			}
			
			//var HUGE_ARR = [];
			
			function duelResponse0(data) {
				console.log(JSON.stringify(data));
				//HUGE_ARR.push(replay_arr.concat())
				
			    //saveGamestate(data);
				switch (data.play) {
					case "To top of deck from field":
					case "To top of deck from hand":
					case "To top of deck from Extra":
					case "To top of deck from grave":
					case "To top of deck from banished":
						data.play = "To T Deck";
						break;
					case "To top of deck FU from field":
						data.play = "To T Deck FU";
						break;
					case "To top of opponent's deck from field":
					case "To Deck 2 FU":
						data.play = "To T Deck 2 FU";
						break;
					case "To top of opponent's deck from opponent's deck":
						data.play = "To T Deck 2";
						break;
					case "To bottom of deck from field":
					case "To bottom of deck from hand":
					case "To bottom of deck from grave":
						data.play = "To B Deck";
						break;
					case "Banish top card of deck":
					case "Banish top card of deck FD":
						if (!data.id) {
							data.id = getPlayer(data.username).main_arr[0].data("id");
						}
						break;
				}
				if (conceal) {
					switch (data.play) {
						case "Add watcher":
							if (data.admin) {
								data.username = "Admin";
							}
							return;
						default:
							console.log('data.play = ' + data.play);
					}
				}
				duelResponse(data);
				switch (data.play) {
					case "Admit defeat":
					case "Quit duel":
					case "Accept draw":
					case "Game loss":
					case "Match loss":
					case "Loss":
						showNextGame();
						break;
				}
			}

			function playE() {
				fast_forwarding = false;
				paused = false;
				if (replay_arr.length > 0) {
					seconds = replay_arr[0].seconds;
				}
				timer.start();
				$('#play_btn').disable(true);
				$('#pause_replay_btn').disable(false);
				$('#fast_btn').disable(false);
				timer.millis = 500;
				timer.reset();
				timer.start();
			}

			function pauseE() {
				fast_forwarding = false;
				paused = true;
				timer.stop();
				$('#play_btn').disable(false);
				$('#pause_replay_btn').disable(true);
				$('#fast_btn').disable(false);
			}
			
			function getAllActiveTweens() {
			    var tweens = TweenMax.getAllTweens();
			    for (var i = 0; i < tweens.length; i++) {
			        //if (tweens[i].target[0] == $('.all_good')[0]) { // there's 2 .all_good's
			        if ($(tweens[i].target[0]).hasClass("all_good")) { // there's 2 .all_good's
			            tweens.splice(0, 1);
			            i--;
			        }
			        else {
			            //console.log('no, ' + tweens[i].target[0] + ' != ' + $('.all_good')[0])
			            console.log('no, ' + cssPath(tweens[i].target[0]) + ' != ' + cssPath($('.all_good')[0]))
			        }
			    }
			    console.log(tweens.length);
			    return tweens;
			}
			
			function printTweens() {
			    var tweens = TweenMax.getAllTweens();
			    for (var i = 0; i < tweens.length; i++) {
			        console.log(tweens[i].target[0]);
			    }
			}

			function nextE() {
				//if (TweenMax.getAllTweens().length > 0) {
				if (getAllActiveTweens().length > 0) {
					console.log("RETURNING INSTEAD OF NEXT PLAY. TweenMax.getAllTweens().length = " + TweenMax.getAllTweens().length);
					printTweens();
					return;
				}
				if (replay_arr.length > 0) {
					seconds = replay_arr[0].seconds;
				}
				console.log('now seconds = ' + seconds);
				timerE();
			}

			function fastE() {
				fast_forwarding = true;
				paused = false;
				if (replay_arr.length > 0) {
					seconds = replay_arr[0].seconds;
				}
				$('#play_btn').disable(false);
				$('#pause_replay_btn').disable(false);
				$('#fast_btn').disable(true);
				timer.millis = 150;
				timer.reset();
				timer.start();
				timerE();
			}
			
			function duelStart(data) { // replay
				ready = false;
				exitTP();
				gotoDueling();
				turnCount = 0;
				TweenMax.fromTo([$('#duel #field_content'), $('#' + currentLabel)], easeSeconds5, {alpha:0}, {alpha:1, delay:easeSeconds2, ease:Linear.easeNone, onComplete:function(){
					if (solo) {
						shiftDecks();
						turn_player = player1;
					}
					if (data.cards) {
						firstCards = data.cards;
					}
					if (version > 1) {
						startingHandSize = data.cards.length / 2;
					}
					if (version == 10 && duelId >= 9753710) {
						startingHandSize = 5;
						if (master == 2) {
							master = 1;
						}
						if (show_cards == 2) {
							showOne();
						}
					}
					if (duelFormat == "so") {
						startingHandSize = 5;
					}
					for (var i = 0; i < startingHandSize; i++) {
						actionsQueue.push(simultaneousDraw);
					}
					actionsQueue.push(function(){
						ready = true;
						if (!unknown_totals) {
							$('#cig2_txt').show();
							$('#cib2_txt').show();
							$('#cig1_txt').show();
							$('#cib1_txt').show();
							$('#cig2_txt').text("0");
							$('#cib2_txt').text("0");
							$('#cig1_txt').text("0");
							$('#cib1_txt').text("0");
						}
						TweenMax.fromTo([$('#cig2_txt'), $('#cib2_txt'), $('#cig1_txt'), $('#cib1_txt')], 1, {alpha:0}, {alpha:1});
						startTurn();
					});			
					stopQueue = false;
					performNextAction();
					$('#field').css("pointer-events", "auto");
				}});
			}
			
			function getShowCards() {
				var show_cards_so = localStorage.getItem("show_cards");
				if (show_cards_so == undefined) {
					show_cards_so = 1;
				}
				if (show_cards_so == 2 && version >= 2 && master == 2) {
					$('#show2_rb').click();
					show_cards = 2;
					showBoth();
				}
				else if (show_cards_so == 0) {
					$('#show_rb').click();
					show_cards = 0;
					showNone();
				}
				else if (version > 1 && master >= 1) {
					show_cards = 1;
					showOne();
				}
				else {
					show_cards = 0;
					showNone();
				}
			}

			function showNone() {
				show_cards = 0;
				rotateCards(player1.hand_arr, 180 + ABOUT_ZERO);
				rotateCards(player2.hand_arr, 180 + ABOUT_ZERO);
				if (tag_duel) {
					rotateCards(player3.hand_arr, 180 + ABOUT_ZERO);
					rotateCards(player4.hand_arr, 180 + ABOUT_ZERO);
				}
				localStorage.setItem("show_cards", 0 + ABOUT_ZERO);
			}

			function showOne() {
				if (version < 2 && switched) {
					return;
				}
				show_cards = 1;
				rotateCards(player1.hand_arr, 0 + ABOUT_ZERO);
				rotateCards(player2.hand_arr, 180 + ABOUT_ZERO);
				if (tag_duel) {
					rotateCards(player3.hand_arr, 0 + ABOUT_ZERO);
					rotateCards(player4.hand_arr, 180 + ABOUT_ZERO);
				}
				localStorage.setItem("show_cards", 1);
			}

			function showBoth() {
				if (version < 2) {
					return;
				}
				show_cards = 2;
				rotateCards(player1.hand_arr, 0 + ABOUT_ZERO);
				rotateCards(player2.hand_arr, 0 + ABOUT_ZERO);
				if (tag_duel) {
					rotateCards(player3.hand_arr, 0 + ABOUT_ZERO);
					rotateCards(player4.hand_arr, 0 + ABOUT_ZERO);
				}
				localStorage.setItem("show_cards", 2);
			}

			function rotateCards(arr, rotationY) {
				for (var i = 0; i < arr.length; i++) {
					TweenMax.set(arr[i], {"rotationY":rotationY});
					arr[i].onRotate();
				}
			}
			
			function simultaneousDraw() {
				var card;
				var card1;
				var rotY = 180 + ABOUT_ZERO;
				if (Player1().main_arr.length > 0) {
					card1 = removeTopCardFromDeck(Player1());
					card = card1;
					Player1().hand_arr.push(card1);
					determineHandPosition(Player1());
					organizeHand(Player1());
					if (show_cards) {
						rotY = 0 + ABOUT_ZERO;
					}
					if (firstCards && firstCards.length > 0) {
						if (switched && firstCards[startingHandSize]) {
							//card1.data("cardfront").initializeFromData(firstCards[startingHandSize]);
							card1.data("cardfront").reinitialize(firstCards[startingHandSize]);
						}
						else if (firstCards[0]) {
							//card1.data("cardfront").initializeFromData(firstCards[0]);
							card1.data("cardfront").reinitialize(firstCards[0]);
						}
					}
					else if (show_cards) {
						show_cards = 0;
						trace("SETTING show_cards TO FALSE");
					}
					TweenMax.to(card1, easeSeconds, {left:handDestination, top:player1.handY, scaleX:0.25, scaleY:0.25, rotation:player1.rot, rotationY:rotY, ease:Linear.easeNone, onComplete:function(){ 
						if (firstCards) {
							firstCards.splice(0, 1);
						}
						endAction();
						if (actionsQueue.length == 0) {
							shiftDeck(Player1());
							shiftDeck(Player2());
						}
					}});
					$('#duel .cards').append(card1);
				}
				var card2;
				if (Player2().main_arr.length > 0) {
					card2 = removeTopCardFromDeck(Player2());
					card = card2;
					Player2().hand_arr.push(card2);
					determineHandPosition(Player2());
					organizeHand(Player2());
					rotY = 180 + ABOUT_ZERO;
					if (show_cards == 2) {
						rotY = 0 + ABOUT_ZERO;
					}
					if (firstCards && firstCards.length > 0) {
						if (switched) {
							//card2.data("cardfront").initializeFromData(firstCards[0]);
							card2.data("cardfront").reinitialize(firstCards[0]);
						}
						else if (firstCards[startingHandSize]) {
							//card2.data("cardfront").initializeFromData(firstCards[startingHandSize]);
							card2.data("cardfront").reinitialize(firstCards[startingHandSize]);
						}
					}
					TweenMax.to(card2, easeSeconds, {left:handDestination, top:player2.handY, scaleX:0.25, scaleY:0.25, rotation:player2.rot, rotationY:rotY, ease:Linear.easeNone});
					$('#duel .cards').append(card2);
				}
				if (!card) {
					endAction();
					return;
				}
				playSound(DrawSound);
			}
			
			function maximizePreview() {
				if (parseInt(preview_txt.css("height")) == 152) {
					if (preview_txt.scrollHeight() >= 159) {
						$('#watchers').hide();
						$('#watchers_btn').hide();
						$('#log_btn').hide();
						preview_txt.css("height", 227);
					}
				}
			}
			
			function openScreenshot(str, usr) {
				var data = JSON.parse(str);
				window.open(data.data.link);
				
				var fd = new FormData();
				fd.append("user_id", userId);
				fd.append("duel_id", duelId);
				fd.append("db_id", db_id);
				fd.append("result", str);
				fd.append("replay", true);

				var xhr = new XMLHttpRequest();
				xhr.open("POST", URL_START + "php-scripts/upload-screenshot.php", true);
				xhr.send(fd);
			}
			
			function likeReplay() {
				$(this).css("opacity", 0.4);
				$(this).css("pointer-events", "none");
				var fd = new FormData();
				fd.append("duel_id", duelId);

				var xhr = new XMLHttpRequest();
				xhr.open("POST", URL_START + "php-scripts/like-replay.php", true);
				xhr.send(fd);
			}
			
			//var GAMESTATE;
			var GAMESTATES = [];
			
			
			
			var PLAYS_TO_SPEED_UP_WHEN_REWINDING = ["Good", "Stop viewing"];
			//FAST_PLAYS
			
			function stepBackwardE() {
			    pauseE();
                //if (stopQueue) {
                //    console.log('cant rewind because stopQueue');
                //    return;
                //}
			    while (previous_plays.length > 0) {
                    if (stopQueue) {
                        console.log('breaking while because stopQueue');
                        break;
                    }
			        var play = previous_plays[previous_plays.length - 1].play;
			        console.log(play);
			        console.log(actionsQueue.length);
			        if (play == "Pick first") {
			            return;
			        }
                    actionsQueue.push(function(){
                        console.log('stepBackwardE');
                        
                        replay_arr.unshift(previous_plays[previous_plays.length - 1]);
                        previous_plays.splice(previous_plays.length - 1, 1);
                
                        restoreGamestate(GAMESTATES[GAMESTATES.length - 2]);
                        GAMESTATES.splice(GAMESTATES.length - 1, 1);
                        GAMESTATES.splice(GAMESTATES.length - 1, 1);
                        
                        
                        printQueue(play);
                        
                        if (FAST_PLAYS.indexOf(play) >= 0) {
                            switch(play) {
                                case "Shuffle deck":
                                    break;
                                default:
                                    endAction(); // because we're in a while loop, endAction needs to be called to advance, and these plays do not use endAction
                            }
                        }
                    });
                    performNextAction();
                    if (FAST_PLAYS.concat(PLAYS_TO_SPEED_UP_WHEN_REWINDING).indexOf(play) < 0 && play.indexOf("View") != 0) {
                        break;
                    }
			    }
			}
			
			function stepBackwardE() {
			    pauseE();
                var play = previous_plays[previous_plays.length - 1].play;
                console.log(play);
                console.log(actionsQueue.length);
                if (play == "Pick first") {
                    console.log('returning cuz pick first');
                    return;
                }
                actionsQueue.push(function(){
                    console.log('stepBackwardE');
                    
                    while (previous_plays.length > 0) {
                        play = previous_plays[previous_plays.length - 1].play;
                        
                        replay_arr.unshift(previous_plays[previous_plays.length - 1]);
                        previous_plays.splice(previous_plays.length - 1, 1);
                        if (FAST_PLAYS.concat(PLAYS_TO_SPEED_UP_WHEN_REWINDING).indexOf(play) < 0 && play.indexOf("View") != 0) {
                            break;
                        }
                    }
            
                    restoreGamestate(GAMESTATES[GAMESTATES.length - 2]);
                    GAMESTATES.splice(GAMESTATES.length - 1, 1);
                    GAMESTATES.splice(GAMESTATES.length - 1, 1);
            
                    printQueue(play);
                    
                    /*if (FAST_PLAYS.indexOf(play) >= 0) {
                        switch(play) {
                            case "Shuffle deck":
                                break;
                            default:
                                endAction(); // because we're in a while loop, endAction needs to be called to advance, and these plays do not use endAction
                        }
                    }*/
                });
                performNextAction();
			}
			
			
			
			

			
			
			var BLAH = "";
			
			function getPlayerObj(player) {
				var obj = {};
                obj.username = player.username;
                obj.pic = $('#avatar' + getPlayerNumber(player) + ' .image').attr("src").substring($('#avatar1 .image').attr("src").lastIndexOf("/") + 1);
                obj.nsfw = $('#avatar' + getPlayerNumber(player) + ' .nsfw').is(":visible");
                obj.rating = player.rating_rep_txt.text().substring(0, player.rating_rep_txt.text().indexOf("/"));
                obj.experience = player.rating_rep_txt.text().substring(player.rating_rep_txt.text().indexOf("/") + 1);
                obj.token = player.token;
                obj.start = player.start;
                //obj.main_total = 
                //obj.extra_total = 
                obj.deck_face_up = player.deck_face_up;
                obj.still_good = $('#avatar' + getPlayerNumber(player) + ' .keep_going').is(":visible");
                obj.done_siding = isPlayer1(player.username) ? $('#done_siding1').is(":visible") : $('#done_siding2').is(":visible");
                obj.countdown = isPlayer1(player.username) ? ($('#countdown1').is(":visible") ? $('#countdown1').text() : undefined) : ($('#countdown2').is(":visible") ? $('#countdown2').text() : undefined);
                obj.skill = player.skill;
                
                
                
                obj.lifepoints = player.lifepoints;
                obj.viewing = isPlayer1(player.username) ? $('#status1 .status_txt').text() : $('#status2 .status_txt').text();
				var field_arr = [player.m1, player.m2, player.m3, player.m4, player.m5, player.s1, player.s2, player.s3, player.s4, player.s5, player.pendulumLeft, player.pendulumRight, player.fieldSpell, player.linkLeft, player.linkRight, player.skillCard];
				obj.field = getPlayerCards(player, field_arr);
				obj.hand = getPlayerCards(player, player.hand_arr);
				obj.main = getPlayerCards(player, player.main_arr);
				obj.grave = getPlayerCards(player, player.grave_arr);
				obj.banished = getPlayerCards(player, player.banished_arr);
				obj.extra = getPlayerCards(player, player.extra_arr);
				return obj;
			}
			
			function getPlayerCards(player, arr) {
				var arr2 = [];
				arr.forEach(function(e,i){
					if (e == null) {
					    arr2.push(null);
					    return false;
					}
					var obj = {};
					obj.id = e.data("id");
					obj.face_up = e.data("face_up") == null ? undefined : !!e.data("face_up");
					obj.face_down = e.data("face_down") == null ? undefined : !!e.data("face_down");
					obj.inATK = e.data("inATK") == null ? undefined : !!e.data("inATK");
					obj.inDEF = e.data("inDEF") == null ? undefined : !!e.data("inDEF");
					obj.counters = e.data("counters") == null ? undefined : array(e.data("counters"));
					obj.controller = e.data("controller").username;
					obj.owner = e.data("owner").username;
					obj.xyz_arr = [];
					e.data("xyz_arr").forEach(function(f,j){
						var material = {};
						material.id = f.data("id");
						material.face_up = f.data("face_up") == null ? undefined : !!f.data("face_up");
						material.face_down = f.data("face_down") == null ? undefined : !!f.data("face_down");
						material.inATK = f.data("inATK") == null ? undefined : !!f.data("inATK");
						material.inDEF = f.data("inDEF") == null ? undefined : !!f.data("inDEF");
						material.counters = f.data("counters") == null ? undefined : array(f.data("counters"));
						material.controller = f.data("controller").username;
						material.owner = f.data("owner").username;
						material.xyz_arr = [];
						//minimizeData(material, e, obj);
						minimizeData(player, e, material);
						obj.xyz_arr.push(material);
					});
					minimizeData(player, e, obj);
					arr2.push(obj);
				});
				return arr2;
			}
			
			function minimizeData(player, card, obj) {
			    if (obj.owner == player.username) {
			        delete obj.owner;
			    }
			    if (obj.controller == player.username) {
			        delete obj.controller;
			    }
			    if (obj.xyz_arr.length == 0) {
			        delete obj.xyz_arr;
			    }
			    if (obj.counters && obj.counters.length == 0) {
			        delete obj.counters;
			    }
			    if (!obj.face_down) {
			        delete obj.face_down;
			    }
			    if (!obj.face_up) {
			        delete obj.face_up;
			    }
			    if (!obj.inATK) {
			        delete obj.inATK;
			    }
			    if (!obj.inDEF) {
			        delete obj.inDEF;
			    }
			    //if (card.data("cardfront").data("card_type") == "Skill") {
			    //    somthing
			    //}
			}
			
			function getPlayerNumber(player) {
			    switch(player) {
			        case player1:
			            return 1;
			        case player2:
			            return 2;
			        case player3:
			            return 3;
			        case player4:
			            return 4;
			    }
			}
			
			function getDuelStatus() {
			    switch(currentLabel) {
			        case "rps_start":
			            return "RPS";
			        case "tp_start":
			        case "tp_start2":
			            return "Pick First";
			        case "duel_start":
			        case "duel_start2":
			        case "duel_start3":
			        case "duel_start4":
			            return "Dueling";
			        case "siding":
			            return "Siding";
			    }
			}
			
            function saveGamestate(data) {
				var GAMESTATE = {};
				GAMESTATE.cards = [];
				var cards = player1.all_cards_arr.concat(player2.all_cards_arr);
				cards.forEach(function(e,i){
				    var obj = {};
				    obj.id = e.data("id");
				    obj.cid = ~~e.data("cardfront").data("id");
				    obj.l = parseFloat(e.css("left"));
				    obj.t = parseFloat(e.css("top"));
				    obj.s = getScale(e[0]) < 0 ? -getScale(e[0]) : getScale(e[0]);
				    obj.r = getRotation(e[0]);
				    //obj.y = ~~getRotationY(e[0]) == 0 ? ABOUT_ZERO : 180 + ABOUT_ZERO;
				    obj.y = ~~getRotationY(e[0]) + ABOUT_ZERO;
				    GAMESTATE.cards.push(obj);
				});
			    GAMESTATE.cards.sort(function(a,b){
                    if (a.id < b.id) {
                        return -1;
                    }
                    if (a.id > b.id) {
                        return 1;
                    }
                    return 0;
                });
				//console.log(JSON.stringify(GAMESTATE.cards));
				
				GAMESTATE.phase = currentPhase;
				    GAMESTATE.paused = paused;
				    GAMESTATE.pausedBy = pausedBy;
                GAMESTATE.player1 = getPlayerObj(player1);
                GAMESTATE.player2 = getPlayerObj(player2);
                if (tag_duel) {
                    GAMESTATE.player3 = getPlayerObj(player3);
                    GAMESTATE.player4 = getPlayerObj(player4);
                } 
                    //GAMESTATE.watchers = JSON.parse(JSON.stringify(watchers_data));
                    //watchers_data = GAMESTATE.watchers;
                GAMESTATE.watchers = $('#watchers').html();
				GAMESTATE.duel_chat = $('#duel .cout_txt').html();
				GAMESTATE.watch_chat = $('#watch_chat .cout_txt').html();
				//GAMESTATE.watch_chat_vsp = watch_chat_vsp;
				//GAMESTATE.watchers = $('#watchers').html();
				GAMESTATE.duel_logs = duel_logs.concat();
                
                GAMESTATE.turnCount = turnCount;
                GAMESTATE.turn_player = turn_player.username;
                GAMESTATE.opponent = turn_player.opponent.username;
                GAMESTATE.active = duel_active;
				GAMESTATE.rpsWinner = rpsWinner;
				GAMESTATE.awaiting_admin = awaiting_admin;
				GAMESTATE.status = getDuelStatus();
				
				GAMESTATE.links = links;
				GAMESTATE.id = duelId;
				GAMESTATE.format = duelFormat;
				GAMESTATE.type = match_type;
				GAMESTATE.tag_duel = tag_duel;
				GAMESTATE.rush = rush;
				GAMESTATE.rated = rated;
				//GAMESTATE.score = 
				//GAMESTATE.adjudicator = adjudicator;
				//GAMESTATE.action = "Watch duel";
				
				//console.log(JSON.stringify(GAMESTATE));
				__GAMESTATE = GAMESTATE;
				GAMESTATES.push(GAMESTATE);
				
				//addLine("Saved gamestate");
				//printQueue();
			}
			
			
		/*	
console.log(GAMESTATES[GAMESTATES.length - 1].player1.field[5]);
console.log(GAMESTATES[GAMESTATES.length - 1].player1.field[7]);
console.log(GAMESTATES[GAMESTATES.length - 1].player1.field[8]);

console.log(GAMESTATES[GAMESTATES.length - 2].player1.field[5]);
console.log(GAMESTATES[GAMESTATES.length - 2].player1.field[7]);
console.log(GAMESTATES[GAMESTATES.length - 2].player1.field[8]);

console.log(GAMESTATES[GAMESTATES.length - 3].player1.field[5]);
console.log(GAMESTATES[GAMESTATES.length - 3].player1.field[7]);
console.log(GAMESTATES[GAMESTATES.length - 3].player1.field[8]);
		*/	
		
		    function parseFloatTenth(str) {
		        var num = parseFloat(str);
		        if (num + 0.25 < Math.ceil(num) && num - 0.25 > Math.floor(num)) {
		            return Math.floor(num) + 0.5;
		        }
		        return Math.round(num);
		    }
		    
		    function difference(num1, num2, diff) {
		        return Math.abs(parseInt(num1) - parseInt(num2)) > diff;
		    }
			
			function restoreGamestate(GAMESTATE) {
			    var tweening = false;
			    GAMESTATE.cards.forEach(function(e,i){
			        var card = getDuelCard(e.id, true);
			        if (card == null) {
			            return;
			        }
			        if (!difference(card.css("left"), e.l, 1) && !difference(card.css("top"), e.t, 1) && !difference(getScale(card[0]), e.s, 1) && !difference(getRotation(card[0]), e.r, 1) && !difference(getRotationY(card[0]), e.y, 1)) {
			            return;
			        }
                    console.log(card.data("controller").username + ": " + card.data("cardfront").data("name"));
                    if (difference(card.css("left"), e.l, 1)) {
                        console.log(card.css("left"));
                        console.log(e.l);
                    }
                    if (difference(card.css("top"), e.t, 1)) {
                        console.log(card.css("top"));
                        console.log(e.t);
                    }
                    if (difference(getScale(card[0]), e.s, 1)) {
                        console.log(getScale(card[0]));
                        console.log(e.s);
                    }
                    if (difference(getRotation(card[0]), e.r, 1)) {
                        console.log(getRotation(card[0]));
                        console.log(e.r);
                    }
                    if (difference(getRotationY(card[0]), e.y, 1)) {
                        console.log(getRotationY(card[0]));
                        console.log(e.y);
                    }
                    //console.log(JSON.stringify({"l":parseFloatTenth(card.css("left")),"t":parseFloatTenth(card.css("top")),"s":getScale(card[0]),"r":getRotation(card[0]),"y":getRotationY(card[0])}));
                    //console.log(JSON.stringify(e));
                    
			        tweening = true;
			        
			        
			        /*if (parseInt(card.css("left")) - parseInt(e.l) < 1 && parseInt(card.css("top")) - parseInt(e.t) < 1 && parseInt(getScale(card[0])) - parseInt(e.s) < 1 && parseInt(getRotation(card[0])) - parseInt(e.r) < 1 && parseInt(getRotationY(card[0])) - parseInt(e.y) < 1) {
			            return;
			        }
			        
			        
			        
			        
			        if (parseFloatTenth(card.css("left")) == parseFloatTenth(e.l) && parseFloatTenth(card.css("top")) == parseFloatTenth(e.t) && parseFloatTenth(getScale(card[0])) == parseFloatTenth(e.s) && parseFloatTenth(getRotation(card[0])) == parseFloatTenth(e.r) && parseFloatTenth(getRotationY(card[0])) == parseFloatTenth(e.y)) {
			            return;
			        }
			        
			        
			        
			        if (parseFloatTenth(card.css("left")) != parseFloatTenth(e.l)) {
			            console.log('Tweening ' + card.data("cardfront").data("name") + ' left');
			        }
			        else if (parseFloatTenth(card.css("top")) != parseFloatTenth(e.t)) {
			            console.log('Tweening ' + card.data("cardfront").data("name") + ' top');
			        }
			        else if (parseFloatTenth(getScale(card[0])) != parseFloatTenth(e.s)) {
			            console.log('Tweening ' + card.data("cardfront").data("name") + ' scale');
			        }
			        else if (parseFloatTenth(getRotation(card[0])) != parseFloatTenth(e.r)) {
			            console.log('Tweening ' + card.data("cardfront").data("name") + ' rotation');
			        }
			        else if (parseFloatTenth(getRotationY(card[0])) != parseFloatTenth(e.y)) {
			            console.log('Tweening ' + card.data("cardfront").data("name") + ' rotationY');
			            console.log(card.data("id"));
			            console.log(getRotationY(card[0]));
			            console.log(parseFloatTenth(getRotationY(card[0])));
			            console.log(e.y);
			            console.log(parseFloatTenth(e.y));
			        }*/
			        
			        //console.log('Tweening ' + card.data("cardfront").data("name"));
			        
			        TweenMax.to(card, easeSeconds, {"left":e.l, "top":e.t, "scale":e.s, "rotation":e.r, "rotationY":e.y, "ease":Linear.easeNone});
			    });
			    setTimeout(function(){
			        resetting = true;
			        
			        all_cards_arr = player1.all_cards_arr.concat(player2.all_cards_arr);
			        player1.resetDeck();
			        player2.resetDeck();
			        if (tag_duel) {
                        player3.resetDeck();
                        player4.resetDeck();
			        }
			        //console.log(player1.s3);
			        initDuel(GAMESTATE);
			        
			        
			        $('#duel .cout_txt').html(GAMESTATE.duel_chat);
			        $('#duel .cout_txt').scrollTop(duel_vsp);
			        
			        $('#watch_chat .cout_txt').html(GAMESTATE.watch_chat);
			        $('#watch_chat .cout_txt').scrollTop(watchers_vsp);
			        
			        //addAllWatchers(GAMESTATE);
			        $('#watchers').html(GAMESTATE.watchers);
			        $('#watchers').scrollTop(watchers_vsp);
			        
			        
			        //console.log(player1.s3);
			        
			        /*exitDueling();
			        watchDuelResponse(GAMESTATE);
			        reinitializeCards(GAMESTATE.cards);
			        getShowCards();*/
			        resetting = false;
			        //GAMESTATES.push(GAMESTATE);
			        //GAMESTATES.push(GAMESTATES[GAMESTATES.length - 1]);
			        endAction();
			        //GAMESTATES.push(GAMESTATES[GAMESTATES.length - 1]);
			        
			        
                    setTimeout(function(){ 
                    //console.log(replay_arr.length);
                        //endAction();
                    }, 1000);
			    }, tweening ? 350 : 0);
			}
			
			//  TweenMax.to(player1.hand_arr[0], 1, {"left":200})
			
			//watchDuelResponse(__GAMESTATE);
			//JSON.stringify(__GAMESTATE.cards)
			//reinitializeCards(__GAMESTATE.cards);
			//JSON.stringify(replay_arr[0])
			
			function reinitializeCards(cards) {
			    cards.forEach(function(e,i){
			        if (!e.cid) {
			            return;
			        }
			        var card = getDuelCard(e.id, true);
			        if (card == null) {
			            console.log('returning');
			            return;
			        }
			        card.data("cardfront").initializeByID(e.cid);
			    });
			}
			
			function printQueue(play) {
                var arr = [];
                for (var i = previous_plays.length - 1; i >= 0; i--) {
                    arr.push(previous_plays[i].play);
                    if (i == previous_plays.length - 3) {
                        break;
                    }
                }
                arr.reverse();
                /*for (var i = 0; i < previous_plays.length; i++) {
                    arr.push(previous_plays[i].play);
                    if (i == 2) {
                        break;
                    }
                }*/
                console.log("%c " + JSON.stringify(arr, null, "	"), "color:red;");
                console.log("%c [" + play + "]", "color:green;");
                
                arr = [];
                for (i = 0; i < replay_arr.length; i++) {
                    arr.push(replay_arr[i].play);
                    if (i == 2) {
                        break;
                    }
                }
                console.log("%c " + JSON.stringify(arr, null, "	"), "color:blue;");
			}
			
			//GAMESTATES.forEach(function(e,i){
			//    console.log(i + ": " + JSON.stringify(e).length);
			//});
			
			//  JSON.stringify(GAMESTATES[GAMESTATES.length - 1]).length;
			//  JSON.stringify(GAMESTATES[0]).length;
			
			
			
			
			//player1.main_arr[0].data()
			
			
			
function sortByName(a,b) { // remove soon
	if (a.name < b.name) {
		return -1;
	}
	if (a.name > b.name) {
		return 1;
	}
	return 0;
}
			
			
			
			
			function hideSelectZones(){}
			
			function removeCardMenu(){}
			
			function enableAdminE(){}
			
			function addCardDragging(){}
			
			function cardMenuE(){}
			
			function menuOutE(){}
			
			function removeCardFromMain(){}
			
			function removeCardFromSide(){}
			
			function removeCardFromExtra(){}

			function deckCardDrop(){}
			
			function sideCardDrop(){}
			
			function extraCardDrop(){}
		</script>
<script src="static/dom-to-image.min.js" async></script>

</body>
</html><script>duelId = 63289651; userId = 1146201; status = ""; master = 2;</script><script>showMes = 1; banner_ad = '<div class="banner-ad" align="center"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"><\/script><ins class="adsbygoogle" style="display: inline-block; width: 728px; height: 90px; pointer-events: auto;" data-ad-client="ca-pub-8917830655675593" data-ad-slot="2153284745"><\/ins><script>(adsbygoogle = window.adsbygoogle || []).push({});<\/script><\/div>'; skinny_ad = '<span class="skinny-ad" align="right"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"><\/script><ins class="adsbygoogle" style="display: inline-block; width: 160px; height: 600px; pointer-events: auto;" data-ad-client="ca-pub-8917830655675593" data-ad-slot="2898742749"><\/ins><script>(adsbygoogle = window.adsbygoogle || []).push({});<\/script><\/span>';</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-ML8JVNMSQY"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-ML8JVNMSQY');
</script>